# Asyncio - lesson 1.1

### Intro

#

> Reading

Read (Until and not including `Async IOâ€™s Roots in Generators`, `Async IO in Context` ): https://realpython.com/async-io-python/#toc

#

> Exercise

Q1: What is asyncio designed for in Python?

Q2: Does asyncio make Python code multithreaded?

Q3: What is the Global Interpreter Lock (GIL)?

Q4: How does asyncio benefit programs that are IO-bound?

Q5: What is a coroutine in asyncio?

Q6: Is asyncio about utilizing multiple CPU cores?

Q7: How does asyncio help programs with idle CPU time during I/O waiting?

Q8: What is the purpose of an event loop in asyncio?

Q10: How does the event loop handle multiple tasks in asyncio?

Q11: What happens when a task yields control in asyncio?

Q12: How does asyncio ensure that CPU time is efficiently shared between tasks?

Q13: Can an event loop forcibly interrupt a coroutine that is currently executing?

Q14: Why is asyncio's approach well-suited for IO-bound code?

**_Notes:_**
* md formating
* Some of these questions feel off, need further examination

